## ReentrantLock API

```java
ReentrantLock() // ReentrantLock(false)를 사용하는 것과 동일하며 내부적으로 NonfairSync 클래스 객체인 불공정성 락을 생성한다.
ReentrantLock(boolean fair) // 주어진 공정성 정책으로 인스턴스를 생성한다. 공정성 락을 사용해야 하는 경우 fair는 true이며 내부적으로 FairSync 클래스 객체를 생성한다.

// 현재 스레드가 이 락을 보유한 횟수를 반환하며 이 락을 보유하지 않은 경우에는 0을 반환한다.
in getHoldCount()

// 현재 스레드가 이 락을 보유하고 있는지 확인한다. 이 메서드는 주로 디버깅 및 테스트에 사용되며 락이 보유될 때만 호출되어야하는 메서드는 이러한 경우를 확인할 수 있다.
boolean isHeldByCurrentThread()

// 스레드가 이 락을 획득하기 위해 대기 중인지 여부를 조회한다.
// 취소는 언제든지 발생할 수 있으므로 true를 반환한다고 해서 다른 스레드가 이 락을 획득한다고 보장하지 않는다. (모니터링 용으로 사용)
boolean hasQueuedThreads()

// 이 락을 획득하기 위해 대기 중인 스레드 수의 추정치를 반환한다.
// 이 값은 내부 데이터 구조를 탐색하는 동안 스레드 수가 동적으로 변경될 수 있기 때문에 실제값과 다를 수 있따. (모니터링 용으로 사용)
int getQueueLength()

// 해당 락과 관련된 지정된 Condition에 대기중인 스레드가 있는지를 조회한다.
// 타임아웃과 인터럽트가 언제든 발생할 수 있기 때문에 true가 반환된다고해서 미래의 신호가 어떤 스레드를 깨우게 할 것임을 보장하지는 않는다. (모니터링 용으로 사용)
boolean hasWaiters(Condition condition)

// 이 락과 관련된 지정된 Condition에 대기 중인 스레드의 수에 대한 추정치를 반환한다.
// 타임아웃과 인터럽트가 언제든 발생할 수 있기 때문에 추정치는 실제 대기 중인 스레드 수에 대한 상한선 역할을 한다. (모니터링 용으로 사용)
int getWaitQueueLength(Condition condition)

// 이 락과 관련된 지정된 Condition에 대기 중인 스레드를 포함하는 컬렉션을 반환한다.
// 실제 스레드 집합이 이 결과를 구성하는 동안 동적으로 변경될 수 있으므로, 반환된 컬렉션은 최선의 추정치에 불과하며 반환된 컬렉션의 요소는 특정한 순서로 나열되지 않는다. (모니터링 용으로 사용) 
```